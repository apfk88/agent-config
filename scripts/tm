#!/usr/bin/env bash
set -euo pipefail

log() { printf '%s\n' "$*"; }
err() { printf 'ERROR: %s\n' "$*" >&2; }
usage() {
  cat <<'USAGE'
Usage:
  tm new [path|url] [branch]    Create repo session (agent-0/agent-1/server/bash)
  tm new <slug>#<branch>        Shorthand for repo + branch
  tm attach            List tmux sessions and attach
  tm list              List tmux sessions
  tm kill              Pick a tmux session to kill
  tm rename [new]      Rename current session (or pick)
  tm help              Show this help
USAGE
}

need_cmd() {
  command -v "$1" >/dev/null 2>&1 || { err "Missing required command: $1"; exit 1; }
}

repo_root_if_inside() {
  if git rev-parse --show-toplevel >/dev/null 2>&1; then
    git rev-parse --show-toplevel
    return 0
  fi
  return 1
}

is_url_like() {
  case "$1" in
    http://*|https://*|git@*|ssh://*|*github.com*|*gitlab.com*|*bitbucket.org*) return 0 ;;
    */*) return 0 ;;
    *) return 1 ;;
  esac
}

repo_name_from() {
  local input="$1"
  input="${input##*/}"
  input="${input%.git}"
  printf '%s' "$input"
}

clone_repo() {
  local input="$1"
  local url="$input"
  local dest_base="$2"
  local branch="${3:-}"

  if [[ "$input" =~ ^[^/]+/[^/]+$ ]]; then
    url="https://github.com/${input}.git"
  fi

  local name
  name="$(repo_name_from "$input")"

  mkdir -p "$dest_base"
  local dest="${dest_base}/${name}"

  if [ -e "$dest" ]; then
    err "Destination exists: ${dest}"
    exit 1
  fi

  if [ -n "$branch" ]; then
    log "Cloning ${url} (branch ${branch}) -> ${dest}"
    git clone --branch "$branch" --single-branch "$url" "$dest"
  else
    log "Cloning ${url} -> ${dest}"
    git clone "$url" "$dest"
  fi
  printf '%s' "$dest"
}

pick_repo() {
  local input="${1:-}"
  local branch_override="${2:-}"
  local branch=""

  if [ -n "$branch_override" ] && [[ "$input" == *"#"* ]]; then
    err "Use either <repo>#<branch> or <repo> <branch>"
    exit 1
  fi

  if [ -z "$branch_override" ] && [[ "$input" == *"#"* ]]; then
    branch="${input#*#}"
    input="${input%%#*}"
    if [ -z "$branch" ]; then
      err "Branch missing after #"
      exit 1
    fi
  else
    branch="$branch_override"
  fi

  if [ -n "$input" ]; then
    if [ -d "$input" ]; then
      printf '%s\t%s' "$(cd "$input" && pwd -P)" "$branch"
      return 0
    fi
    if is_url_like "$input"; then
      local base
      read -r -p "Clone into (default: $HOME/dev): " base
      base="${base:-$HOME/dev}"
      printf '%s\t%s' "$(clone_repo "$input" "$base" "$branch")" "$branch"
      return 0
    fi
    err "Not a repo path or URL: $input"
    exit 1
  fi

  local inside=""
  if inside="$(repo_root_if_inside)"; then
    printf '%s\t%s' "$inside" "$branch"
    return 0
  fi

  read -r -p "Repo path or GitHub URL: " input
  if [ -z "$input" ]; then
    err "No input"
    exit 1
  fi

  if [ -d "$input" ]; then
    printf '%s\t%s' "$(cd "$input" && pwd -P)" "$branch"
    return 0
  fi

  if is_url_like "$input"; then
    local base
    read -r -p "Clone into (default: $HOME/dev): " base
    base="${base:-$HOME/dev}"
    printf '%s\t%s' "$(clone_repo "$input" "$base" "$branch")" "$branch"
    return 0
  fi

  err "Not a repo path or URL: $input"
  exit 1
}

attach_or_switch() {
  local session="$1"
  if [ -n "${TMUX-}" ]; then
    tmux switch-client -t "$session"
  else
    tmux attach -t "$session"
  fi
}

get_sessions() {
  tmux list-sessions -F '#S' 2>/dev/null || true
}

choose_session() {
  local sessions
  sessions="$(get_sessions)"
  if [ -z "$sessions" ]; then
    err "No tmux sessions"
    exit 1
  fi

  log "Sessions:"
  local i=1
  while IFS= read -r s; do
    printf '  [%s] %s\n' "$i" "$s"
    i=$((i + 1))
  done <<<"$sessions"

  local choice
  read -r -p "Choose session #: " choice
  if ! [[ "$choice" =~ ^[0-9]+$ ]]; then
    err "Invalid choice"
    exit 1
  fi

  local idx=1
  local target=""
  while IFS= read -r s; do
    if [ "$idx" -eq "$choice" ]; then
      target="$s"
      break
    fi
    idx=$((idx + 1))
  done <<<"$sessions"

  if [ -z "$target" ]; then
    err "Invalid choice"
    exit 1
  fi

  printf '%s' "$target"
}

attach_session() {
  local target
  target="$(choose_session)"
  attach_or_switch "$target"
}

list_sessions() {
  local sessions
  sessions="$(get_sessions)"
  if [ -z "$sessions" ]; then
    err "No tmux sessions"
    exit 1
  fi

  log "Sessions:"
  local i=1
  while IFS= read -r s; do
    printf '  [%s] %s\n' "$i" "$s"
    i=$((i + 1))
  done <<<"$sessions"

}

kill_session() {
  local target
  target="$(choose_session)"
  tmux kill-session -t "$target"
  log "Killed: $target"
}

current_session() {
  tmux display-message -p '#S' 2>/dev/null || true
}

rename_session() {
  local new_name="${1:-}"
  local old_name=""

  if [ -n "$new_name" ] && [ -n "${TMUX-}" ]; then
    old_name="$(current_session)"
  elif [ -n "$new_name" ] && [ -z "${TMUX-}" ]; then
    old_name="$(choose_session)"
  else
    old_name="$(choose_session)"
    read -r -p "New name: " new_name
  fi

  if [ -z "$new_name" ]; then
    err "No new name"
    exit 1
  fi

  if tmux has-session -t "$new_name" 2>/dev/null; then
    err "Session exists: $new_name"
    exit 1
  fi

  tmux rename-session -t "$old_name" "$new_name"
  log "Renamed: $old_name -> $new_name"
}

switch_branch() {
  local repo_dir="$1"
  local branch="$2"

  if [ -z "$branch" ]; then
    return 0
  fi

  if [ -n "$(git -C "$repo_dir" status --porcelain)" ]; then
    err "Dirty repo, wonâ€™t checkout branch: ${branch}"
    exit 1
  fi

  if git -C "$repo_dir" show-ref --verify --quiet "refs/heads/$branch"; then
    git -C "$repo_dir" checkout "$branch"
    return 0
  fi

  if git -C "$repo_dir" show-ref --verify --quiet "refs/remotes/origin/$branch"; then
    git -C "$repo_dir" checkout -b "$branch" "origin/$branch"
    return 0
  fi

  err "Branch not found: $branch"
  exit 1
}

new_session() {
  local repo_dir
  local branch="${2:-}"
  local picked=""
  local picked_branch=""
  picked="$(pick_repo "${1:-}" "$branch")"
  IFS=$'\t' read -r repo_dir picked_branch <<<"$picked"

  if ! git -C "$repo_dir" rev-parse --show-toplevel >/dev/null 2>&1; then
    err "Not a git repo: ${repo_dir}"
    exit 1
  fi

  switch_branch "$repo_dir" "$picked_branch"

  local session
  session="$(basename "$repo_dir")"

  if tmux has-session -t "$session" 2>/dev/null; then
    attach_or_switch "$session"
    return 0
  fi

  tmux new-session -d -s "$session" -c "$repo_dir" -n agent-0
  tmux new-window -t "$session":1 -n agent-1 -c "$repo_dir"
  tmux new-window -t "$session":2 -n server -c "$repo_dir"
  tmux new-window -t "$session":3 -n bash -c "$repo_dir"
  tmux new-window -t "$session":4 -n tips -c "$repo_dir" "nano \"$repo_dir/tips.md\""

  attach_or_switch "$session"
}

main() {
  need_cmd tmux
  need_cmd git

  local cmd="${1:-new}"
  case "$cmd" in
    new)
      shift
      new_session "${1:-}"
      ;;
    attach)
      attach_session
      ;;
    list)
      list_sessions
      ;;
    kill)
      kill_session
      ;;
    rename)
      shift
      rename_session "${1:-}"
      ;;
    -h|--help|help)
      usage
      ;;
    help)
      usage
      ;;
    *)
      err "Unknown command: $cmd"
      usage
      exit 1
      ;;
  esac
}

main "$@"
